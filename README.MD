Руководство по Stream

Это руководство раскрывает основы написания node.js программ с использованием потоков. 

Введение

Концепция потоков пришла к нам почти с момента зарождения unix и зарекомендовала себя как надежный способ построения больших систем из небольших компонентов, чья функция -- делать хорошо всего одну вещь. В unix поток можно реализовать при помощи shell путем добавления | pipe. В node.js присутствует встроенный модуль 'stream', используемый в ядре node, но его можно использовать и в пользовательских модулях. Как и в unix, модуль 'stream' прежде всего включает в состав оператор .pipe(), благодаря которому вы имеете возможность написать некий регулятор.

Потоки помогают разделить ваши задачи, поскольку ограничивают зону поверхности выполнения в последовательных интерфейсах, что способствует переиспользованию кода. В дальнейшем можно перенаправить выход одного потока на вход другого и использовать библиотеки, которые позволяют оперировать потоками на более высоком уровне абстракции. 

Потоки - это очень важный компонент <a href="https://michaelochurch.wordpress.com/2012/08/15/what-is-spaghetti-code/">дизайна маленьких программ</a> философии unix, но есть и другие важные абстракции, которые стоит рассмотреть. Просто запомните, что <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%85%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B4%D0%BE%D0%BB%D0%B3">технический долг</a> - это враг и всегда необходимо искать лучшие абстракции для решаемой задачи.

Почему необходимо использовать потоки?

Операции ввода/вывода в node.js являются асинхронными, поэтому взаимодействие с диском и сетью включают в себя передачу коллбек-функций. У вас может возникнуть соблазн написать код, подобный этому: 

<code>
	var http = require('http');
	var fs = require('fs');

	var server = http.createServer(function (req, res) {
	    fs.readFile(__dirname + '/data.txt', function (err, data) {
	        res.end(data);
	    });
	});
	server.listen(8000);
</code> 

Этот код будет работать, но он довольно громоздкий и сохраняет целый файл data.txt в памяти для каждого запроса, перед тем как отдать результат клиенту. Если data.txt очень большой, ваша программа будет съедать очень много памяти, так как она используется многими пользователями одновременно, особенно заметно это будет пользователям с медленным соединением. 

Из-за этого обстоятельства обедняется UX, поскольку пользователь должен ждать пока весь файл на сервере попадет в буфер и только после этого получит его себе. 

К счастью, оба аргумента req и res являются потоками, и это можно использовать для написания нашего файлового сервера. Более продуктивно в данном случае использовать метод fs.createReadStream(), а не fs.readFile():

<code>
	var http = require('http');
	var fs = require('fs');

	var server = http.createServer(function (req, res) {
	    var stream = fs.createReadStream(__dirname + '/data.txt');
	    stream.pipe(res);
	});
	server.listen(8000);
</code>

Метод .pipe() в этом примере заботится о прослушивании для событий 'data' и 'end' из метода fs.createReadStream(). Этот код еще не является идеальным, но не смотря на это, сейчас файл data.txt будет поступать клиенту порциями по мере их поступления с диска. 

Используя .pipe(), можно получить и другие приемущества, такие как <a href="http://www.techopedia.com/definition/24131/backpressure">automatically handling backpressure</a> - node.js не будет помещать куски данных в память без нужды, когда удаленный клиент использует очень медленное соединение, например.

Хотите сжать файл? Существуют потоковые модули для того, чтобы это сделать!
<code>
	var http = require('http');
	var fs = require('fs');
	var oppressor = require('oppressor');

	var server = http.createServer(function (req, res) {
	    var stream = fs.createReadStream(__dirname + '/data.txt');
	    stream.pipe(oppressor(req)).pipe(res);
	});
	server.listen(8000);
</code> 

Сейчас файл data.txt сжимается для браузеров, которые поддерживают gzip или Deflate. Мы можем просто воспользоваться модулем oppressor для обработки всего контента.

Однажды изучив stream api, вы сможете просто объединять вместе потоковые модули, как кубики лего или САДОВЫЙ ШЛАНГ, вместо того, чтобы помнить как отправить данные через шаткие непотоковые самодельные API. 

